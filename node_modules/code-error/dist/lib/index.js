'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ansiToHtml = require('ansi-to-html');

var _ansiToHtml2 = _interopRequireDefault(_ansiToHtml);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _es6Error = require('es6-error');

var _es6Error2 = _interopRequireDefault(_es6Error);

var _stripAnsi = require('strip-ansi');

var _stripAnsi2 = _interopRequireDefault(_stripAnsi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const a2h = new _ansiToHtml2.default();

const defaults = {
  maxLines: 8,
  highlightColour: 'red'
};

// file, contents, line, column, endLine, endColumn
class CodeError extends _es6Error2.default {
  constructor(message, options) {
    super(message);

    Object.assign(this, defaults, options);

    Object.defineProperty(this, '__CodeError', { value: true });

    if (_chalk2.default[this.highlightColour]) this.highlight = _chalk2.default[this.highlightColour];else this.highlight = _chalk2.default.red;
  }

  get ansiExcerpt() {
    // array of lines that will form the report
    const report = [];

    // add source lines
    if (this.contents != null && this.line != null) {
      const lines = [];

      let line = this.line + 1;
      let max = this.maxLines;
      const mostDigits = String(this.line).length + 1;
      const sourceSplit = this.contents.toString().split('\n');
      let digitGap;

      while (line-- > 1 && max-- > 0) {
        digitGap = spaces(mostDigits - String(line).length);
        let lineReport = '  ' + digitGap + _chalk2.default.grey(line) + _chalk2.default.grey(' ┃ ');

        if (line === this.line) lineReport += sourceSplit[line - 1]; // the error line: bright
        else lineReport += _chalk2.default.grey(sourceSplit[line - 1]); // non-error line: dim

        lines.unshift(lineReport);
      }

      report.push(lines.join('\n'));

      // add a line to show column of error
      if (this.column != null) {
        digitGap = spaces(mostDigits);
        report.push(digitGap + spaces(this.column + 5) + this.highlight('↑'));
      } else report.push('');
    }

    // put it together
    return report.join('\n');
  }

  get excerpt() {
    return (0, _stripAnsi2.default)(this.ansiExcerpt);
  }

  get htmlExcerpt() {
    return a2h.toHtml(this.ansiExcerpt.replace(/&/g, '&amp;').replace(/</g, '&lt;'));
  }

  /**
   * Suffix for appending to the file path to indicate error position.
   * e.g. ":12:34" means line 12, char 34
   */
  get suffix() {
    let suffix = '';

    if (this.line != null) {
      suffix += ':' + this.line;
      if (this.column != null) suffix += ':' + this.column;
    }

    return suffix;
  }
}

exports.default = CodeError;
function spaces(count) {
  return new Array(count).join(' ');
}
//# sourceMappingURL=index.js.map